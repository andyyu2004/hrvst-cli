import fs from "fs";
import { camelCase, kebabCase, omit, upperFirst } from "lodash";
import path from "path";
import {
  CollectionDefinition,
  ItemDefinition,
  ItemGroupDefinition,
  QueryParamDefinition,
  RequestDefinition,
  Url,
  UrlDefinition,
  VariableDefinition,
} from "postman-collection";
import { format } from "prettier";
import yargs, { Arguments, Argv } from "yargs";
import { urlArgOptions } from "../src/util/postman-request-command";

type CommandDictionary = Record<string, string>;

const commandsDir = path.join("src", "generated-commands");
const docsDir = path.join("docs", "generated-commands");
const readmeTemplate = path.join("tools", "readme-template.md");

const FILE_HEADER = `/**
 * This file was generated by running \`yarn generate\` and should NOT be modified.
 */`;

yargs
  .command(
    "$0 <postman-export-file>",
    "Generate yargs commands from a Postman Collection v2.1 export",
    (yargs: Argv) => {
      return yargs.positional("postman-export-file", {
        demandOption: true,
        description: "Path to Postman Collection v2.1 export file",
      });
    },
    async ({ postmanExportFile }: Arguments<{ postmanExportFile: string }>) => {
      // Parse Postman export file
      const exportContent = await fs.promises.readFile(
        postmanExportFile,
        "utf-8"
      );
      const collection: CollectionDefinition = JSON.parse(exportContent);
      const commandDictionary: CommandDictionary = {};

      for (const dir of [commandsDir, docsDir]) {
        await fs.promises.rm(dir, { force: true, recursive: true });
        await mkdir(dir);
      }

      if (collection.item) {
        for (const item of collection.item) {
          await createCommandModule(item);
          Object.assign(commandDictionary, await createDocs(item));
        }
      }

      await updateReadme(commandDictionary);
    }
  )
  .demandCommand()
  .strict()
  .version(false).argv;

/**
 * Generates yargs command modules for a Postman collection item
 *
 * @param item Postman item
 * @param parentItem Parent of `item`
 * @param currentDir Current command path
 */
async function createCommandModule(
  item: ItemDefinition | ItemGroupDefinition,
  parentItem?: ItemDefinition | ItemGroupDefinition,
  currentDir: string = commandsDir
): Promise<void> {
  const name = commandName(item, parentItem);
  const commandPath = path.join(currentDir, name);

  if ("request" in item && item.request) {
    // Create command module for endpoint
    await writeFile(
      path.join(currentDir, `${name}.ts`),
      commandModule(name, item.request, path.relative(currentDir, "src"))
    );
  } else if ("item" in item && item.item?.length) {
    // Create command directory
    await mkdir(commandPath);

    // Create command module that registers the command directory
    await writeFile(
      path.join(currentDir, `${name}.ts`),
      commandDirModule(name, item.description as string)
    );

    // Recursively generate commands for nested endpoints
    for (const i of item.item) {
      await createCommandModule(i, item, commandPath);
    }
  }
}

/**
 * Generates CLI documentation for a Postman collection item
 *
 * @param item Postman item
 * @param parentItem Parent of `item`
 * @param commands Parent command names in hierarchical order
 * @param currentDir Current command path
 */
async function createDocs(
  item: ItemDefinition | ItemGroupDefinition,
  parentItem?: ItemDefinition | ItemGroupDefinition,
  commands: string[] = [],
  currentDir: string = docsDir
): Promise<CommandDictionary> {
  const name = commandName(item, parentItem);
  const commandPath = path.join(currentDir, name);
  const filename = (name: string) => `${upperFirst(camelCase(name))}.md`;
  const commandDictionary: CommandDictionary = {};
  const itemCommands: Record<string, ItemDefinition> = {};

  if ("item" in item && item.item?.length) {
    let content = `# ${item.name}\n${item.description}`;

    commands.push(name);

    for (const i of item.item) {
      if ("request" in i && i.request) {
        const options = urlArgOptions(new Url(i.request.url));
        const cmd = `hrvst ${commands.join(" ")} ${commandName(i, item)}`;
        itemCommands[cmd] = i;

        content += `\n## ${i.name}\n${i.request.description}`;
        content += `\n\`\`\`\n${cmd}\n\`\`\``;

        if (Object.keys(options).length) {
          content += markdownTable(
            ["Option", "Description", "Required"],
            Object.keys(options).map((key) => [
              `\`--${key}\``,
              options[key].describe,
              options[key].demandOption,
            ])
          );
        }
      } else {
        await mkdir(commandPath);
        Object.assign(
          commandDictionary,
          await createDocs(i, item, [...commands], commandPath)
        );
      }
    }

    if (content.length) {
      const docsPath = path.join(currentDir, filename(name));
      for (const command in itemCommands) {
        commandDictionary[command] = `${docsPath}#${kebabCase(
          itemCommands[command].name
        )}`;
      }
      await writeFile(docsPath, content);
    }
  }

  return commandDictionary;
}

/**
 * Substitute variables in tools/README-template.md and copy to the root of the
 * projects as README.md
 *
 * @param dictionary Map of command to documentation link
 */
async function updateReadme(dictionary: CommandDictionary): Promise<void> {
  const sortedCommands = Object.keys(dictionary).sort((a, b) => {
    const aParts = a.split(" ");
    const bParts = b.split(" ");
    const aLastPositional = aParts.pop() || "";
    const bLastPositional = bParts.pop() || "";
    const aLength = aParts.length;
    const bLength = bParts.length;

    if (aLength == bLength) {
      for (let i = 1; i < aLength; i++) {
        const compare = aParts[i].localeCompare(bParts[i]);
        if (compare != 0) {
          return compare;
        }
      }
    }
    return (
      aParts.join().localeCompare(bParts.join()) ||
      aLastPositional.localeCompare(bLastPositional) ||
      aLength - bLength
    );
  });

  const content = sortedCommands
    .map((c) => `<a href="/${dictionary[c]}">${c}</a>`)
    .join("\n");
  const readme = await fs.promises.readFile(readmeTemplate, "utf-8");
  await fs.promises.writeFile(
    "README.md",
    readme.replace("{{COMMAND_DICTIONARY}}", content)
  );
}

/**
 * Returns file content for command module that registers a command directory
 *
 * @param name Command name
 * @param description  Command description
 * @returns File content
 */
const commandDirModule = (
  name: string,
  description: string
): string => `${FILE_HEADER}
import { CommandBuilder } from 'yargs';
export const command = '${name} <command>';
export const description = \`${description.split("\n")[0]}\`;
export const builder: CommandBuilder = (yargs) => yargs.commandDir('${name}').version(false);
`;

/**
 * Returns file content for command module to make an API request
 *
 * @param name Command name
 * @param request Postman request definition
 * @param relativeSrc Relative path to src to use for imports
 * @returns File content
 */
const commandModule = (
  name: string,
  request: RequestDefinition & { url: UrlDefinition },
  relativeSrc: string
): string => `${FILE_HEADER}
import postmanRequestCommand, { Request } from "${relativeSrc}/util/postman-request-command";

export const request: Request = ${JSON.stringify({
  method: request.method,
  url: ((r) => {
    // Remove dummy values
    const clearValues = (
      variables?: QueryParamDefinition[] | VariableDefinition[]
    ) =>
      variables?.forEach(
        (v: QueryParamDefinition | VariableDefinition) => (v.value = "")
      );
    clearValues(r.url.query as QueryParamDefinition[]);
    clearValues(r.url.variable);
    return omit(r.url, "raw");
  })(request),
})};
export const { command, aliases, describe, builder, handler } = postmanRequestCommand({
  command: '${name}',
  describe: '${(request.description as string).split(".")[0]}',
  request,
});
`;

/**
 * Returns the verb from the Postman item name
 *
 * @param itemName Name of Postman item
 * @returns Shorter version of itemName or itemName
 */
const commandName = (
  item: ItemDefinition | ItemGroupDefinition,
  parentItem?: ItemDefinition | ItemGroupDefinition
): string => {
  let name = kebabCase(item.name) || "";

  if ("request" in item) {
    if (name.match(/^(create|delete|list|restart|retrieve|stop|update)-/i)) {
      const url = item.request?.url as UrlDefinition;
      const path = Array.isArray(url?.path) ? url.path : [];

      name = name.split("-")[0].replace("retrieve", "get");

      // The "me" endpoints can conflict with other command names so just use
      // "me" as the command name
      if (path.indexOf("me") >= 0) {
        name = "me";
      }

      // Handle extra "list" endpoints that contain path variables that will
      // conflict with the standard list commmand
      const idPath = path.findIndex((p) => p.charAt(0) === ":");
      if (name === "list" && idPath !== -1) {
        name += `-by-${kebabCase(
          path[idPath].substring(1, path[idPath].lastIndexOf("_"))
        )}`;
      }
      return name;
    }
  }

  if (parentItem) {
    const parentName = commandName(parentItem);
    const prefix = name.split("-")[0];

    if (parentName.match(new RegExp(`^${prefix}`))) {
      name = name.substring(name.indexOf("-") + 1, name.length);
    }
  }

  // Remove "a" and "an" from command names
  return name.replace(/-an?-/g, "-");
};

/**
 * Create a markdown table for the given column names and values
 *
 * @param head Name of table head columns
 * @param body Array of array of body column values
 * @returns Markdown format for table
 */
function markdownTable(
  head: string[],
  body: (boolean | string | undefined)[][]
): string {
  const separators = head.map(() => "---");
  const bodyRows = body.map((row) => row.join(" | "));
  return `
| ${head.join(" | ")} |
| ${separators.join(" | ")} |
${bodyRows.join("\n")}`;
}

/**
 * Create directory if it does not already exist
 *
 * @param dir Directory path
 */
async function mkdir(dir: string): Promise<void> {
  if (!fs.existsSync(dir)) {
    await fs.promises.mkdir(dir);
  }
}

/**
 * Write contents to file and format using prettier
 *
 * @param filepath Path to file (also used to infer parser for prettier)
 * @param content File content
 */
async function writeFile(filepath: string, content: string): Promise<void> {
  if (fs.existsSync(filepath)) {
    console.warn(`Overwriting ${filepath}`);
  }
  await fs.promises.writeFile(
    filepath,
    format(content, {
      filepath,
    })
  );
}
